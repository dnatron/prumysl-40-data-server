### ğŸ§  **Prompt: VÃ½voj centrÃ¡lnÃ­ho sbÄ›rnÃ©ho serveru pro prÅ¯myslovÃ¡ data (Industry 4.0 â€“ FÃ¡ze 2)**

VytvoÅ™ **centrÃ¡lnÃ­ sbÄ›rnÃ½ server**, kterÃ½ se aktivnÄ› pÅ™ipojuje k simulovanÃ½m nebo skuteÄnÃ½m prÅ¯myslovÃ½m zaÅ™Ã­zenÃ­m (PLC) prostÅ™ednictvÃ­m protokolÅ¯ **OPC UA** a **Modbus TCP**, pravidelnÄ› Äte data a uklÃ¡dÃ¡ je do lokÃ¡lnÃ­ databÃ¡ze. Server bude mÃ­t **webovÃ© rozhranÃ­** pro sprÃ¡vu zdrojÅ¯ a zobrazenÃ­ aktuÃ¡lnÃ­ch i historickÃ½ch hodnot.

#### ğŸ”§ **TechnologickÃ½ stack**
- **Backend**: Python 3.12 + FastAPI
- **ORM/DatovÃ½ model**: SQLModel
- **DatabÃ¡ze**: SQLite (`data.sqlite`) â€“ **uklÃ¡dÃ¡ se zde konfigurace i mÄ›Å™enÃ­**
- **Frontend**: Jinja2, Bootstrap 5, HTMX (bez JavaScript frameworku)
- **Protokoly**:
  - OPC UA klient: `opcua-asyncio` nebo `freeopcua`
  - Modbus TCP klient: `pymodbus` (async reÅ¾im)

#### ğŸ¯ **HlavnÃ­ funkce**
1. **SprÃ¡va zdrojÅ¯ dat**:
   - UÅ¾ivatel mÅ¯Å¾e pÅ™idat/editovat/zakÃ¡zat zdroj (napÅ™. â€Lis-01â€œ)
   - Pro kaÅ¾dÃ½ zdroj specifikuje:
     - NÃ¡zev
     - Protokol (`opcua` nebo `modbus`)
     - Host (`127.0.0.1`)
     - Port (`4840` pro OPC UA, `5020` pro Modbus)
     - (u OPC UA) endpoint URL, napÅ™. `opc.tcp://127.0.0.1:4840`
2. **Definice tagÅ¯/senzorÅ¯**:
   - Pro kaÅ¾dÃ½ zdroj lze pÅ™idat vÃ­ce tagÅ¯:
     - NÃ¡zev (napÅ™. â€Teplota olejeâ€œ)
     - Adresa:  
       - OPC UA: napÅ™. `ns=2;s=Teplota`  
       - Modbus: napÅ™. `hr_0` (holding register 0)
     - DatovÃ½ typ (`float`, `int`, `bool`)
3. **PravidelnÃ½ sbÄ›r dat**:
   - KaÅ¾dÃ½ch **5 sekund** (konfigurovatelnÃ©) server:
     - ProchÃ¡zÃ­ vÅ¡echny **aktivnÃ­** zdroje
     - Pro kaÅ¾dÃ½ tag zavolÃ¡ odpovÃ­dajÃ­cÃ­ho klienta (OPC nebo Modbus)
     - NaÄtenou hodnotu uloÅ¾Ã­ do tabulky `Measurement` s ÄasovÃ½m razÃ­tkem
4. **WebovÃ© rozhranÃ­**:
   - **Dashboard**: tabulka se **seznamem zdrojÅ¯** + poslednÃ­ znÃ¡mÃ© hodnoty
   - **Detail zdroje**: strÃ¡nka s historiÃ­ mÄ›Å™enÃ­ pro vÅ¡echny jeho tagy (poslednÃ­ch 100 zÃ¡znamÅ¯)
   - MoÅ¾nost **ruÄnÄ› spustit jednorÃ¡zovÃ½ ÄtenÃ­** (pro test)

#### ğŸ–¥ï¸ **PoÅ¾adavky na UI**
- HlavnÃ­ strÃ¡nka (`/`) zobrazuje tabulku:
  | ID | NÃ¡zev stroje | Protokol | PoslednÃ­ aktualizace | Teplota | Tlak | Stav |
  |----|--------------|----------|------------------------|---------|------|------|
  â†’ Sloupce s hodnotami senzorÅ¯ se dynamicky generujÃ­ podle definovanÃ½ch tagÅ¯
- KaÅ¾dÃ½ Å™Ã¡dek mÃ¡ tlaÄÃ­tko â€Detailâ€œ â†’ pÅ™esmÄ›ruje na `/source/{id}`
- Na detailu: grafickÃ© zobrazenÃ­ nenÃ­ vyÅ¾adovÃ¡no, staÄÃ­ tabulka mÄ›Å™enÃ­
- VÅ¡echny interakce (pÅ™idÃ¡nÃ­, spuÅ¡tÄ›nÃ­ ÄtenÃ­) probÃ­hajÃ­ pÅ™es **HTMX** â€“ bez full-page reloadu

#### ğŸ“¦ **SloÅ¾kovÃ¡ struktura a popis souborÅ¯**

```
data-gateway/
â”‚
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ main.py                 # FastAPI app: routy pro UI, HTMX handlers, spuÅ¡tÄ›nÃ­ polleru
â”‚   â”œâ”€â”€ models.py               # SQLModel: Source, Tag, Measurement
â”‚   â”œâ”€â”€ opc_client.py           # Async funkce pro ÄtenÃ­ z OPC UA serveru
â”‚   â”œâ”€â”€ modbus_client.py        # Async funkce pro ÄtenÃ­ z Modbus TCP serveru
â”‚   â””â”€â”€ poller.py               # AsynchronÃ­ smyÄka pro pravidelnÃ© dotazovÃ¡nÃ­ zdrojÅ¯
â”‚
â”œâ”€â”€ frontend/
â”‚   â”œâ”€â”€ templates/
â”‚   â”‚   â”œâ”€â”€ base.html           # ZÃ¡kladnÃ­ Å¡ablona (Bootstrap + HTMX)
â”‚   â”‚   â”œâ”€â”€ dashboard.html      # HlavnÃ­ pÅ™ehled zdrojÅ¯ + poslednÃ­ hodnoty
â”‚   â”‚   â”œâ”€â”€ source_form.html    # FormulÃ¡Å™ pro pÅ™idÃ¡nÃ­/editaci zdroje + tagÅ¯
â”‚   â”‚   â””â”€â”€ source_detail.html  # Detail zdroje: historie mÄ›Å™enÃ­
â”‚   â”‚
â”‚   â””â”€â”€ static/
â”‚       â””â”€â”€ style.css           # VolitelnÃ© vlastnÃ­ styly
â”‚
â”œâ”€â”€ data.sqlite                 # SQLite databÃ¡ze: obsahuje Source, Tag i Measurement
â”œâ”€â”€ requirements.txt            # fastapi, uvicorn, sqlmodel, opcua, pymodbus, jinja2, python-multipart
â””â”€â”€ README.md                   # NÃ¡vod: jak spustit, jak pÅ™idat zdroj, jak funguje sbÄ›r
```

#### ğŸ“„ **StruÄnÃ½ popis klÃ­ÄovÃ½ch souborÅ¯**

- **`models.py`**  
  â†’ Definuje:
  - `Source`: metadata o zdroji (host, port, protokol)
  - `Tag`: nÃ¡zev, adresa, datovÃ½ typ, vazba na zdroj
  - `Measurement`: `value` (float), `timestamp`, vazba na tag

- **`poller.py`**  
  â†’ AsynchronÃ­ Ãºloha, kterÃ¡ kaÅ¾dÃ½ch `interval` sekund:
  - NaÄte vÅ¡echny aktivnÃ­ zdroje
  - Pro kaÅ¾dÃ½ tag zavolÃ¡ `read_opcua_value()` nebo `read_modbus_register()`
  - UloÅ¾Ã­ vÃ½sledek jako `Measurement`

- **`opc_client.py`**  
  â†’ Funkce: `async read_opcua_value(endpoint: str, node_id: str) -> float`

- **`modbus_client.py`**  
  â†’ Funkce: `async read_modbus_holding_register(host: str, port: int, reg: int) -> float`

- **`main.py`**  
  â†’ Obsahuje:
  - FastAPI instanci
  - Routy pro renderovÃ¡nÃ­ Å¡ablon
  - HTMX POST handlery (uloÅ¾enÃ­ zdroje, spuÅ¡tÄ›nÃ­ manuÃ¡lnÃ­ho ÄtenÃ­)
  â†’ PÅ™i startu aplikace spustÃ­ `poller` jako `asyncio.create_task()`

- **Å ablony**  
  â†’ `dashboard.html` dynamicky vytvÃ¡Å™Ã­ sloupce podle tagÅ¯ (napÅ™. pomocÃ­ `{% for tag in source.tags %}`)

#### ğŸš« **OmezenÃ­**
- Å½Ã¡dnÃ© ovÄ›Å™ovÃ¡nÃ­ (auth) â€“ bÄ›Å¾Ã­ lokÃ¡lnÄ› pro vÃ½voj
- Å½Ã¡dnÃ© pokroÄilÃ© vizualizace (grafy) â€“ pouze tabulky
- Frekvence sbÄ›ru pevnÃ¡ na 5 s (pro vÃ½voj)

#### âœ… **KritÃ©rium ÃºspÄ›chu**
- SpustÃ­Å¡ simulÃ¡tor PLC (fÃ¡ze 1) na portu 4840 (OPC UA) s tagem â€Teplotaâ€œ
- Ve sbÄ›rnÃ©m serveru pÅ™idÃ¡Å¡ zdroj â€Lis-01â€œ s OPC UA endpointem `opc.tcp://127.0.0.1:4840`
- DefinujeÅ¡ tag â€Teplotaâ€œ s adresou `ns=2;s=Teplota`
- Po 5 sekundÃ¡ch se v dashboardu zobrazÃ­ aktuÃ¡lnÃ­ hodnota
- StejnÃ© funguje pro Modbus TCP simulÃ¡tor

---

 Zde je dodateÄnÃ½ popis ohlednÄ› podobnosti sqlmodelu:

SkvÄ›lÃ¡ otÃ¡zka! Ano, **architektura jako v Kepware KEPServerEX** je pÅ™esnÄ› to, co potÅ™ebujeÅ¡ â€“ tedy **hierarchickou, flexibilnÃ­ a protokol-nezÃ¡vislou strukturu**, kde:

- KaÅ¾dÃ½ **zdroj (device/stroj)** mÃ¡ svÅ¯j typ protokolu (OPC UA, Modbus, â€¦),
- KaÅ¾dÃ½ zdroj mÃ¡ **seznam tagÅ¯ (promÄ›nnÃ½ch)** s adresou specifickou pro danÃ½ protokol,
- Tagy mohou mÃ­t rÅ¯znÃ© **datovÃ© typy** a **metadata**,
- A vÅ¡e je **rozÅ¡iÅ™itelnÃ©** pro dalÅ¡Ã­ protokoly.

V kontextu **SQLModel + SQLite** (nebo pozdÄ›ji PostgreSQL) by mÄ›l datovÃ½ model vypadat nÃ¡sledovnÄ›:

---

### âœ… **DoporuÄenÃ¡ SQLModel struktura (inspirovÃ¡no Kepware)**

```python
from sqlmodel import SQLModel, Field, Relationship
from typing import List, Optional
from datetime import datetime

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 1. ZDROJ (Device / PLC / Stroj)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class Device(SQLModel, table=True):
    id: int = Field(default=None, primary_key=True)
    name: str = Field(index=True, description="NapÅ™. 'Lis-01', 'ÄŒerpadlo-A'")
    protocol: str = Field(description="napÅ™. 'opcua', 'modbus'")  # enum v produkci
    host: str = "127.0.0.1"
    port: int
    enabled: bool = True
    description: Optional[str] = None

    # Vztah k tagÅ¯m
    tags: List["Tag"] = Relationship(back_populates="device")


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 2. TAG (PromÄ›nnÃ¡ / Senzor / DatovÃ½ bod)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class Tag(SQLModel, table=True):
    id: int = Field(default=None, primary_key=True)
    name: str = Field(description="NapÅ™. 'Teplota_motoru', 'Stav_RUN'")  # unikÃ¡tnÃ­ v rÃ¡mci zaÅ™Ã­zenÃ­
    address: str = Field(description="""
        Protokol-specifickÃ¡ adresa:
        - OPC UA: 'ns=2;s=Teplota' nebo 'i=2258'
        - Modbus: 'hr_40001' (holding register 40001),
                  'co_1' (coil 1),
                  'ir_30001' (input register)
    """)
    data_type: str = Field(default="float", description="float, int, bool, string")
    description: Optional[str] = None
    enabled: bool = True

    # Vazba na zaÅ™Ã­zenÃ­
    device_id: int = Field(foreign_key="device.id")
    device: Device = Relationship(back_populates="tags")

    # Vztah k mÄ›Å™enÃ­m
    measurements: List["Measurement"] = Relationship(back_populates="tag")


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 3. MÄšÅ˜ENÃ (Hodnota v Äase)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class Measurement(SQLModel, table=True):
    id: int = Field(default=None, primary_key=True)
    value: float  # vÅ¡e se normalizuje na float pro jednoduchost; pro bool: 0/1
    timestamp: datetime = Field(default_factory=datetime.utcnow)

    # Vazba na tag
    tag_id: int = Field(foreign_key="tag.id")
    tag: Tag = Relationship(back_populates="measurements")
```

---

### ğŸ” **ProÄ takto?**

| Prvek | VÃ½hoda |
|------|--------|
| **`Device`** | Reprezentuje fyzickÃ© nebo simulovanÃ© zaÅ™Ã­zenÃ­ â€“ odpovÃ­dÃ¡ â€Channel â†’ Deviceâ€œ v Kepware |
| **`Tag`** | KaÅ¾dÃ½ datovÃ½ bod je nezÃ¡visle konfigurovatelnÃ½ â€“ jako â€Tagâ€œ v Kepware |
| **`address` jako Å™etÄ›zec** | FlexibilnÃ­ pro jakÃ½koli protokol â€“ parser se pÅ™izpÅ¯sobÃ­ podle `device.protocol` |
| **`data_type`** | UmoÅ¾Åˆuje sprÃ¡vnÃ© zpracovÃ¡nÃ­ (napÅ™. bool vs. float) i v UI |
| **`Measurement` oddÄ›lenÃ½** | OptimalizovÃ¡no pro ÄasovÃ© Å™ady â€“ pozdÄ›ji snadnÃ¡ migrace na TimescaleDB |

---

### ğŸ§© **PÅ™Ã­klad dat v praxi**

#### ZaÅ™Ã­zenÃ­ (Device)
```json
{
  "name": "Lis-01",
  "protocol": "opcua",
  "host": "127.0.0.1",
  "port": 4840
}
```

#### Tagy (Tags)
```json
[
  {
    "name": "Teplota_oleje",
    "address": "ns=2;s=Lis01.Temperature",
    "data_type": "float"
  },
  {
    "name": "Stav_RUN",
    "address": "ns=2;s=Lis01.Running",
    "data_type": "bool"
  }
]
```

#### Nebo pro Modbus:
```json
{
  "name": "ÄŒerpadlo-B",
  "protocol": "modbus",
  "host": "127.0.0.1",
  "port": 5020
}
```
```json
[
  {
    "name": "Tlak_vstup",
    "address": "hr_40001",
    "data_type": "float"
  },
  {
    "name": "Alarm_vysoka_teplota",
    "address": "co_1",
    "data_type": "bool"
  }
]
```

> ğŸ’¡ **PoznÃ¡mka k Modbus adresÃ¡m**:  
> DoporuÄuji pouÅ¾Ã­t prefixy pro jasnost:
> - `hr_` = holding register (ÄtenÃ­/zÃ¡pis)
> - `ir_` = input register (jen ÄtenÃ­)
> - `co_` = coil (ÄtenÃ­/zÃ¡pis, bool)
> - `di_` = discrete input (jen ÄtenÃ­, bool)

---

### âš™ï¸ **Jak to pouÅ¾ije tvÅ¯j sbÄ›rnÃ½ server?**

1. NaÄte vÅ¡echny `Device` s `enabled=True`
2. Pro kaÅ¾dÃ½ `Device`:
   - Podle `protocol` zvolÃ­ klienta (OPC UA nebo Modbus)
   - Pro kaÅ¾dÃ½ `Tag` s `enabled=True`:
     - PÅ™evede `address` na formÃ¡t poÅ¾adovanÃ½ protokolem
     - PÅ™eÄte hodnotu
     - Pokud je `data_type == "bool"`, pÅ™evede na `0/1` â†’ uloÅ¾Ã­ do `value: float`
     - VloÅ¾Ã­ `Measurement(tag_id=..., value=..., timestamp=...)`

---

### ğŸ”„ **RozÅ¡iÅ™itelnost pro budoucnost**

- ChceÅ¡ pÅ™idat **MQTT**? â†’ PÅ™idej `protocol = "mqtt"`, `address = "factory/machine1/temp"`
- ChceÅ¡ **vzorkovacÃ­ interval na Ãºrovni tagu**? â†’ PÅ™idej `scan_rate_sec: int = 5` do `Tag`
- ChceÅ¡ **kvalitu dat (Quality)**? â†’ PÅ™idej `quality: str = "good"` do `Measurement`

---

### âœ… ShrnutÃ­

Ano â€“ tento model **naprosto odpovÃ­dÃ¡ pÅ™Ã­stupu Kepware KEPServerEX**, ale v jednoduchÃ©, lightweight formÄ› vhodnÃ© pro Python + SQLite vÃ½voj. Je:

- **Protokol-neutrÃ¡lnÃ­**
- **HierarchickÃ½** (Device â†’ Tag â†’ Measurement)
- **Snadno rozÅ¡iÅ™itelnÃ½**
- **KompatibilnÃ­ s prÅ¯myslovÃ½mi nÃ¡stroji** (OPC klienty, Modbus scannery)


Zde je upravenÃ½ Prompt pro  aby bral ohled na podobnost s Kepware KEPServerEX:

Pro centrÃ¡lnÃ­ sbÄ›rnÃ½ server (fÃ¡ze 2)**, kterÃ½ plnÄ› reflektuje **Kepware-inspirovanou architekturu** s entitami **Device â†’ Tag â†’ Measurement** a podporou pro vÃ­ce protokolÅ¯ (OPC UA, Modbus) v rÃ¡mci jednoho systÃ©mu.

---

### ğŸ§  **Prompt: VÃ½voj centrÃ¡lnÃ­ho sbÄ›rnÃ©ho serveru pro prÅ¯myslovÃ¡ data (Industry 4.0 â€“ FÃ¡ze 2, verze s Kepware-style architekturou)**

VytvoÅ™ **centrÃ¡lnÃ­ sbÄ›rnÃ½ server**, kterÃ½ se pÅ™ipojuje k simulovanÃ½m nebo reÃ¡lnÃ½m prÅ¯myslovÃ½m zaÅ™Ã­zenÃ­m prostÅ™ednictvÃ­m standardnÃ­ch protokolÅ¯ (**OPC UA**, **Modbus TCP**) a pravidelnÄ› sbÃ­rÃ¡ data definovanÃ¡ jako **tagy**. Architektura musÃ­ bÃ½t **flexibilnÃ­, rozÅ¡iÅ™itelnÃ¡ a inspirovÃ¡na Kepware KEPServerEX**:  
kaÅ¾dÃ© zaÅ™Ã­zenÃ­ (Device) mÅ¯Å¾e mÃ­t rÅ¯znÃ© tagy s protokol-specifickÃ½mi adresami, a vÅ¡echna mÄ›Å™enÃ­ se uklÃ¡dajÃ­ s ÄasovÃ½m razÃ­tkem.

#### ğŸ”§ **TechnologickÃ½ stack**
- **Backend**: Python 3.12 + FastAPI
- **ORM**: SQLModel
- **DatabÃ¡ze**: SQLite (`data.sqlite`) â€“ obsahuje **Device**, **Tag** i **Measurement**
- **Frontend**: Jinja2 + Bootstrap 5 + HTMX (bez JavaScript frameworku)
- **Protokoly**:
  - OPC UA klient: `opcua-asyncio`
  - Modbus TCP klient: `pymodbus` (async)

---

### ğŸ¯ **KlÃ­ÄovÃ© entity (Kepware-style model)**

1. **Device** â€“ reprezentuje jedno prÅ¯myslovÃ© zaÅ™Ã­zenÃ­ (napÅ™. PLC â€Lis-01â€œ)
   - `name`, `protocol` (`opcua` / `modbus`), `host`, `port`, `enabled`
2. **Tag** â€“ reprezentuje jeden datovÃ½ bod (senzor, stav, ÄÃ­taÄ)
   - `name`, `address` (protokol-specifickÃ¡: napÅ™. `ns=2;s=Teplota` nebo `hr_40001`)
   - `data_type` (`float`, `int`, `bool`), `enabled`
   - Vazba na `Device`
3. **Measurement** â€“ historickÃ¡ hodnota tagu v Äase
   - `value` (normalizovÃ¡no na `float`), `timestamp`, vazba na `Tag`

---

### âš™ï¸ **FunkÄnÃ­ poÅ¾adavky**

#### A. SprÃ¡va zaÅ™Ã­zenÃ­ a tagÅ¯
- UÅ¾ivatel mÅ¯Å¾e pÅ™idat/upravit/smazat **Device**
- Pro kaÅ¾dÃ© zaÅ™Ã­zenÃ­ lze pÅ™idat vÃ­ce **TagÅ¯** s:
  - NÃ¡zvem (unikÃ¡tnÃ­ v rÃ¡mci zaÅ™Ã­zenÃ­)
  - Adresou ve formÃ¡tu:
    - **OPC UA**: `ns=2;s=Teplota`, `i=2258`
    - **Modbus**: `hr_40001` (holding register), `co_1` (coil), `ir_30001` (input register)
  - DatovÃ½m typem (ovlivnÃ­ zpÅ¯sob interpretace a zobrazenÃ­)

#### B. SbÄ›r dat
- AsynchronnÃ­ **poller** kaÅ¾dÃ½ch **5 sekund**:
  - ProchÃ¡zÃ­ vÅ¡echny `enabled=True` Device
  - Pro kaÅ¾dÃ½ jeho `enabled=True` Tag:
    - NaÄte hodnotu pomocÃ­ odpovÃ­dajÃ­cÃ­ho klienta (OPC UA / Modbus)
    - Normalizuje bool â†’ `0.0`/`1.0`, int â†’ float
    - UloÅ¾Ã­ `Measurement(tag_id=..., value=..., timestamp=...)`
- Chyby pÅ™i ÄtenÃ­ se logujÃ­, ale nezastavujÃ­ celÃ½ cyklus

#### C. WebovÃ© rozhranÃ­
- **Dashboard (`/`)** zobrazuje:
  - Tabulku **Device** s poslednÃ­mi hodnotami vÅ¡ech jeho tagÅ¯  
    â†’ sloupce: `ID | NÃ¡zev | Protokol | Teplota | Stav_RUN | PoslednÃ­ aktualizace`
  - DynamickÃ© sloupce podle definovanÃ½ch tagÅ¯
- **Detail zaÅ™Ã­zenÃ­ (`/device/{id}`)**:
  - ZobrazÃ­ historii mÄ›Å™enÃ­ pro vÅ¡echny jeho tagy (poslednÃ­ch 100 zÃ¡znamÅ¯)
- **FormulÃ¡Å™ pro vytvoÅ™enÃ­ zaÅ™Ã­zenÃ­**:
  - Volba protokolu â†’ dynamicky naÄte nÃ¡povÄ›du k formÃ¡tu adresy
  - MoÅ¾nost pÅ™idat vÃ­ce tagÅ¯ v jednom formulÃ¡Å™i (repeatable section)

#### D. TechnickÃ© poÅ¾adavky
- VÅ¡echny operace (uloÅ¾enÃ­, spuÅ¡tÄ›nÃ­ manuÃ¡lnÃ­ho ÄtenÃ­) pÅ™es **HTMX**
- Å½Ã¡dnÃ© pÅ™ihlaÅ¡ovÃ¡nÃ­ â€“ aplikace bÄ›Å¾Ã­ lokÃ¡lnÄ› pro vÃ½voj
- Data se uklÃ¡dajÃ­ do **`data.sqlite`** â€“ vÄetnÄ› mÄ›Å™enÃ­

---

### ğŸ“¦ **SloÅ¾kovÃ¡ struktura a struÄnÃ½ popis souborÅ¯**

```
data-gateway/
â”‚
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ main.py                 # FastAPI app: routy, HTMX handlery, spuÅ¡tÄ›nÃ­ polleru
â”‚   â”œâ”€â”€ models.py               # SQLModel: Device, Tag, Measurement (Kepware-style)
â”‚   â”œâ”€â”€ opc_client.py           # Async ÄtenÃ­ z OPC UA (podle address typu)
â”‚   â”œâ”€â”€ modbus_client.py        # Async ÄtenÃ­ z Modbus (parsuje hr_/co_/ir_)
â”‚   â””â”€â”€ poller.py               # AsynchronÃ­ smyÄka pro prÅ¯bÄ›Å¾nÃ© dotazovÃ¡nÃ­
â”‚
â”œâ”€â”€ frontend/
â”‚   â”œâ”€â”€ templates/
â”‚   â”‚   â”œâ”€â”€ base.html           # HlavnÃ­ Å¡ablona (Bootstrap + HTMX)
â”‚   â”‚   â”œâ”€â”€ dashboard.html      # PÅ™ehled zaÅ™Ã­zenÃ­ + poslednÃ­ hodnoty tagÅ¯
â”‚   â”‚   â”œâ”€â”€ device_form.html    # FormulÃ¡Å™ pro Device + Tagy
â”‚   â”‚   â””â”€â”€ device_detail.html  # Historie mÄ›Å™enÃ­ pro konkrÃ©tnÃ­ zaÅ™Ã­zenÃ­
â”‚   â””â”€â”€ static/
â”‚       â””â”€â”€ style.css           # VolitelnÃ© styly
â”‚
â”œâ”€â”€ data.sqlite                 # JednotnÃ¡ databÃ¡ze: metadata i mÄ›Å™enÃ­
â”œâ”€â”€ requirements.txt            # fastapi, uvicorn, sqlmodel, opcua, pymodbus, jinja2
â””â”€â”€ README.md                   # NÃ¡vod k pouÅ¾itÃ­
```

---

### âœ… **KritÃ©rium ÃºspÄ›chu**
- PÅ™idÃ¡Å¡ Device â€Lis-01â€œ (OPC UA, `127.0.0.1:4840`) se dvÄ›ma tagy:  
  `Teplota` (`ns=2;s=Lis01.Temp`, float) a `RUN` (`ns=2;s=Lis01.Run`, bool)
- PÅ™idÃ¡Å¡ Device â€ÄŒerpadlo-Bâ€œ (Modbus, `127.0.0.1:5020`) s tagy:  
  `Tlak` (`hr_40001`, float) a `Alarm` (`co_1`, bool)
- Po spuÅ¡tÄ›nÃ­ se v dashboardu zobrazujÃ­ aktuÃ¡lnÃ­ hodnoty obou zaÅ™Ã­zenÃ­
- Data se pravidelnÄ› uklÃ¡dajÃ­ do `Measurement`

---

Tento prompt je nynÃ­ **pÅ™esnÄ› v souladu s prÅ¯myslovou praxÃ­** a zÃ¡roveÅˆ optimalizovÃ¡n pro tvÅ¯j stack (Python + SQLite + HTMX). Je pÅ™ipraven k pouÅ¾itÃ­ pro vÃ½voj nebo generovÃ¡nÃ­ kÃ³du.
